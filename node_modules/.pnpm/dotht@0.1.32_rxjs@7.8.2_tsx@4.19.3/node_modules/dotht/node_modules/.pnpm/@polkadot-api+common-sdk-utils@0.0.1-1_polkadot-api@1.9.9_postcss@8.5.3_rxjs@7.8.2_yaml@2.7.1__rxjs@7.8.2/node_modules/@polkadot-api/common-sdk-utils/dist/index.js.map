{"version":3,"file":"index.js","sources":["../src/flattenResult.ts","../src/asyncTransaction.ts"],"sourcesContent":["const isResult = (value: unknown): value is Result =>\n  typeof value === \"object\" &&\n  !!value &&\n  \"success\" in value &&\n  \"value\" in value &&\n  typeof value.success === \"boolean\"\n\nexport type Result<S = unknown, E = unknown> =\n  | { success: true; value: S }\n  | { success: false; value: E }\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * { value: number } | null\n */\nexport const flattenValues = <T>(v: T): { value: FlattenValues<T> } | null => {\n  const result = flattenResult(v)\n  return result.success ? { value: result.value } : null\n}\nexport type FlattenValues<T> =\n  IsAny<T> extends true\n    ? any\n    : T extends Result\n      ? FlattenValues<(T & { success: true })[\"value\"]>\n      : T\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * { error: ErrorA | ErrorB | ErrorC } | null\n */\nexport const flattenErrors = <T>(v: T): { error: FlattenErrors<T> } | null => {\n  const result = flattenResult(v)\n  return result.success ? null : { error: result.value }\n}\nexport type FlattenErrors<T> =\n  IsAny<T> extends true\n    ? any\n    : T extends Result\n      ?\n          | (T & { success: false })[\"value\"]\n          | FlattenErrors<(T & { success: true })[\"value\"]>\n      : never\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * Result<number, ErrorA | ErrorB | ErrorC>\n */\nexport const flattenResult = <T>(v: T): FlattenResult<T> =>\n  isResult(v)\n    ? v.success\n      ? (flattenResult as any)(v.value)\n      : { success: false, value: v.value }\n    : { success: true, value: v }\nexport type FlattenResult<T> = T extends Result\n  ? Result<FlattenValues<T>, FlattenErrors<T>>\n  : never\n\n// `any extends number ? true : false` ==> boolean. So we have to double-check\n// setting the case for `false` to `boolean` for a bit more clarification.\ntype IsAny<T> = (any extends T ? true : boolean) extends true ? true : false\n\nexport function mapResult<SI, EI, SO = SI, EO = EI>(\n  result: Result<SI, EI>,\n  mapFns: {\n    value?: (value: SI) => SO\n    error?: (error: EI) => EO\n  },\n): Result<SO, EO> {\n  return result.success\n    ? {\n        success: true,\n        value: mapFns.value?.(result.value) ?? result.value,\n      }\n    : ({\n        success: false,\n        value: mapFns.error?.(result.value) ?? result.value,\n      } as any)\n}\n","import type { Transaction, Binary } from \"polkadot-api\"\nimport { from, switchMap } from \"rxjs\"\n\nexport type AsyncTransaction<\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset,\n> = Omit<\n  Transaction<Arg, Pallet, Name, Asset>,\n  \"decodedCall\" | \"getEncodedData\"\n> & {\n  decodedCall: Promise<Transaction<Arg, Pallet, Name, Asset>[\"decodedCall\"]>\n  getEncodedData: () => Promise<Binary>\n}\n\nexport const wrapAsyncTx = <\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset,\n>(\n  fn: () => Promise<Transaction<Arg, Pallet, Name, Asset>>,\n): AsyncTransaction<Arg, Pallet, Name, Asset> => {\n  const promise = fn()\n  return {\n    sign: (...args) => promise.then((tx) => tx.sign(...args)),\n    signSubmitAndWatch: (...args) =>\n      from(promise).pipe(switchMap((tx) => tx.signSubmitAndWatch(...args))),\n    signAndSubmit: (...args) => promise.then((tx) => tx.signAndSubmit(...args)),\n    getEstimatedFees: (...args) =>\n      promise.then((tx) => tx.getEstimatedFees(...args)),\n    getPaymentInfo: (...args) =>\n      promise.then((tx) => tx.getPaymentInfo(...args)),\n    decodedCall: promise.then((tx) => tx.decodedCall),\n    getEncodedData: () => promise.then((tx) => tx.getEncodedData()),\n  }\n}\n"],"names":["from","switchMap"],"mappings":";;;;AAAA,MAAM,QAAW,GAAA,CAAC,KAChB,KAAA,OAAO,UAAU,QACjB,IAAA,CAAC,CAAC,KAAA,IACF,aAAa,KACb,IAAA,OAAA,IAAW,KACX,IAAA,OAAO,MAAM,OAAY,KAAA,SAAA;AAUd,MAAA,aAAA,GAAgB,CAAI,CAA6C,KAAA;AAC5E,EAAM,MAAA,MAAA,GAAS,cAAc,CAAC,CAAA;AAC9B,EAAA,OAAO,OAAO,OAAU,GAAA,EAAE,KAAO,EAAA,MAAA,CAAO,OAAU,GAAA,IAAA;AACpD;AAYa,MAAA,aAAA,GAAgB,CAAI,CAA6C,KAAA;AAC5E,EAAM,MAAA,MAAA,GAAS,cAAc,CAAC,CAAA;AAC9B,EAAA,OAAO,OAAO,OAAU,GAAA,IAAA,GAAO,EAAE,KAAA,EAAO,OAAO,KAAM,EAAA;AACvD;AAca,MAAA,aAAA,GAAgB,CAAI,CAC/B,KAAA,QAAA,CAAS,CAAC,CACN,GAAA,CAAA,CAAE,OACC,GAAA,aAAA,CAAsB,CAAE,CAAA,KAAK,IAC9B,EAAE,OAAA,EAAS,KAAO,EAAA,KAAA,EAAO,CAAE,CAAA,KAAA,KAC7B,EAAE,OAAA,EAAS,IAAM,EAAA,KAAA,EAAO,CAAE;AAShB,SAAA,SAAA,CACd,QACA,MAIgB,EAAA;AAChB,EAAA,OAAO,OAAO,OACV,GAAA;AAAA,IACE,OAAS,EAAA,IAAA;AAAA,IACT,OAAO,MAAO,CAAA,KAAA,GAAQ,MAAO,CAAA,KAAK,KAAK,MAAO,CAAA;AAAA,GAE/C,GAAA;AAAA,IACC,OAAS,EAAA,KAAA;AAAA,IACT,OAAO,MAAO,CAAA,KAAA,GAAQ,MAAO,CAAA,KAAK,KAAK,MAAO,CAAA;AAAA,GAChD;AACN;;AC7Da,MAAA,WAAA,GAAc,CAMzB,EAC+C,KAAA;AAC/C,EAAA,MAAM,UAAU,EAAG,EAAA;AACnB,EAAO,OAAA;AAAA,IACL,IAAA,EAAM,CAAI,GAAA,IAAA,KAAS,OAAQ,CAAA,IAAA,CAAK,CAAC,EAAA,KAAO,EAAG,CAAA,IAAA,CAAK,GAAG,IAAI,CAAC,CAAA;AAAA,IACxD,kBAAoB,EAAA,CAAA,GAAI,IACtB,KAAAA,SAAA,CAAK,OAAO,CAAE,CAAA,IAAA,CAAKC,cAAU,CAAA,CAAC,OAAO,EAAG,CAAA,kBAAA,CAAmB,GAAG,IAAI,CAAC,CAAC,CAAA;AAAA,IACtE,aAAA,EAAe,CAAI,GAAA,IAAA,KAAS,OAAQ,CAAA,IAAA,CAAK,CAAC,EAAA,KAAO,EAAG,CAAA,aAAA,CAAc,GAAG,IAAI,CAAC,CAAA;AAAA,IAC1E,gBAAA,EAAkB,CAAI,GAAA,IAAA,KACpB,OAAQ,CAAA,IAAA,CAAK,CAAC,EAAA,KAAO,EAAG,CAAA,gBAAA,CAAiB,GAAG,IAAI,CAAC,CAAA;AAAA,IACnD,cAAA,EAAgB,CAAI,GAAA,IAAA,KAClB,OAAQ,CAAA,IAAA,CAAK,CAAC,EAAA,KAAO,EAAG,CAAA,cAAA,CAAe,GAAG,IAAI,CAAC,CAAA;AAAA,IACjD,aAAa,OAAQ,CAAA,IAAA,CAAK,CAAC,EAAA,KAAO,GAAG,WAAW,CAAA;AAAA,IAChD,cAAA,EAAgB,MAAM,OAAQ,CAAA,IAAA,CAAK,CAAC,EAAO,KAAA,EAAA,CAAG,gBAAgB;AAAA,GAChE;AACF;;;;;;;;"}