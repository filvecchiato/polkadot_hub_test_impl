{"version":3,"file":"flattenResult.mjs","sources":["../../src/flattenResult.ts"],"sourcesContent":["const isResult = (value: unknown): value is Result =>\n  typeof value === \"object\" &&\n  !!value &&\n  \"success\" in value &&\n  \"value\" in value &&\n  typeof value.success === \"boolean\"\n\nexport type Result<S = unknown, E = unknown> =\n  | { success: true; value: S }\n  | { success: false; value: E }\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * { value: number } | null\n */\nexport const flattenValues = <T>(v: T): { value: FlattenValues<T> } | null => {\n  const result = flattenResult(v)\n  return result.success ? { value: result.value } : null\n}\nexport type FlattenValues<T> =\n  IsAny<T> extends true\n    ? any\n    : T extends Result\n      ? FlattenValues<(T & { success: true })[\"value\"]>\n      : T\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * { error: ErrorA | ErrorB | ErrorC } | null\n */\nexport const flattenErrors = <T>(v: T): { error: FlattenErrors<T> } | null => {\n  const result = flattenResult(v)\n  return result.success ? null : { error: result.value }\n}\nexport type FlattenErrors<T> =\n  IsAny<T> extends true\n    ? any\n    : T extends Result\n      ?\n          | (T & { success: false })[\"value\"]\n          | FlattenErrors<(T & { success: true })[\"value\"]>\n      : never\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * Result<number, ErrorA | ErrorB | ErrorC>\n */\nexport const flattenResult = <T>(v: T): FlattenResult<T> =>\n  isResult(v)\n    ? v.success\n      ? (flattenResult as any)(v.value)\n      : { success: false, value: v.value }\n    : { success: true, value: v }\nexport type FlattenResult<T> = T extends Result\n  ? Result<FlattenValues<T>, FlattenErrors<T>>\n  : never\n\n// `any extends number ? true : false` ==> boolean. So we have to double-check\n// setting the case for `false` to `boolean` for a bit more clarification.\ntype IsAny<T> = (any extends T ? true : boolean) extends true ? true : false\n\nexport function mapResult<SI, EI, SO = SI, EO = EI>(\n  result: Result<SI, EI>,\n  mapFns: {\n    value?: (value: SI) => SO\n    error?: (error: EI) => EO\n  },\n): Result<SO, EO> {\n  return result.success\n    ? {\n        success: true,\n        value: mapFns.value?.(result.value) ?? result.value,\n      }\n    : ({\n        success: false,\n        value: mapFns.error?.(result.value) ?? result.value,\n      } as any)\n}\n"],"names":[],"mappings":"AAAA,MAAM,QAAW,GAAA,CAAC,KAChB,KAAA,OAAO,UAAU,QACjB,IAAA,CAAC,CAAC,KAAA,IACF,aAAa,KACb,IAAA,OAAA,IAAW,KACX,IAAA,OAAO,MAAM,OAAY,KAAA,SAAA;AAUd,MAAA,aAAA,GAAgB,CAAI,CAA6C,KAAA;AAC5E,EAAM,MAAA,MAAA,GAAS,cAAc,CAAC,CAAA;AAC9B,EAAA,OAAO,OAAO,OAAU,GAAA,EAAE,KAAO,EAAA,MAAA,CAAO,OAAU,GAAA,IAAA;AACpD;AAYa,MAAA,aAAA,GAAgB,CAAI,CAA6C,KAAA;AAC5E,EAAM,MAAA,MAAA,GAAS,cAAc,CAAC,CAAA;AAC9B,EAAA,OAAO,OAAO,OAAU,GAAA,IAAA,GAAO,EAAE,KAAA,EAAO,OAAO,KAAM,EAAA;AACvD;AAca,MAAA,aAAA,GAAgB,CAAI,CAC/B,KAAA,QAAA,CAAS,CAAC,CACN,GAAA,CAAA,CAAE,OACC,GAAA,aAAA,CAAsB,CAAE,CAAA,KAAK,IAC9B,EAAE,OAAA,EAAS,KAAO,EAAA,KAAA,EAAO,CAAE,CAAA,KAAA,KAC7B,EAAE,OAAA,EAAS,IAAM,EAAA,KAAA,EAAO,CAAE;AAShB,SAAA,SAAA,CACd,QACA,MAIgB,EAAA;AAChB,EAAA,OAAO,OAAO,OACV,GAAA;AAAA,IACE,OAAS,EAAA,IAAA;AAAA,IACT,OAAO,MAAO,CAAA,KAAA,GAAQ,MAAO,CAAA,KAAK,KAAK,MAAO,CAAA;AAAA,GAE/C,GAAA;AAAA,IACC,OAAS,EAAA,KAAA;AAAA,IACT,OAAO,MAAO,CAAA,KAAA,GAAQ,MAAO,CAAA,KAAK,KAAK,MAAO,CAAA;AAAA,GAChD;AACN;;;;"}